import {
  Connection,
  PublicKey,
  Transaction,
  SystemProgram,
  sendAndConfirmTransaction,
} from '@solana/web3.js';
import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
import {
  SimpleMarket,
  SimplePosition,
  CreateSimpleMarketParams,
  MarketStatus,
  Outcome,
} from '../types';
import * as anchor from '@coral-xyz/anchor';

const SIMPLE_PREDICTION_MARKET_PROGRAM_ID = new PublicKey('simpPredM3mP9vK8JqF2nH5xY7wD4bC6eA8g');
const MARKET_STATE_SEED = 'market_state';
const MARKET_SEED = 'market';
const POSITION_SEED = 'position';

type SimplePredictionMarket = any;

export class SimplePredictionMarketClient {
  private connection: Connection;
  private program: Program<SimplePredictionMarket>;
  private provider: AnchorProvider;
  public readonly programId: PublicKey;

  constructor(config: { programId?: PublicKey; rpcUrl: string; network: string }, wallet: Wallet) {
    this.programId = config.programId || SIMPLE_PREDICTION_MARKET_PROGRAM_ID;
    
    this.connection = new Connection(config.rpcUrl, 'confirmed');
    this.provider = new AnchorProvider(
      this.connection,
      wallet,
      { commitment: 'confirmed' }
    );
    
    // Note: IDL will be generated by Anchor build
    // @ts-ignore - IDL will be loaded after anchor build, types will be correct then
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    this.program = new Program({} as any, this.programId, this.provider) as Program<any>;
  }

  private async getMarketStatePDA(): Promise<[PublicKey, number]> {
    return PublicKey.findProgramAddress(
      [Buffer.from(MARKET_STATE_SEED)],
      this.programId
    );
  }

  private async getMarketPDA(marketId: bigint): Promise<[PublicKey, number]> {
    const marketIdBuffer = Buffer.allocUnsafe(8);
    marketIdBuffer.writeBigUInt64LE(marketId, 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(MARKET_SEED), marketIdBuffer],
      this.programId
    );
  }

  private async getPositionPDA(marketId: bigint, user: PublicKey): Promise<[PublicKey, number]> {
    const marketIdBuffer = Buffer.allocUnsafe(8);
    marketIdBuffer.writeBigUInt64LE(marketId, 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(POSITION_SEED), marketIdBuffer, user.toBuffer()],
      this.programId
    );
  }

  /**
   * Initialize the prediction market program
   */
  async initialize(oracleProgram: PublicKey, feePercentage: number = 200): Promise<string> {
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    // @ts-ignore - Method types will be available after IDL generation
    const tx = await (this.program.methods as any)
      .initialize(oracleProgram, feePercentage)
      .accounts({
        marketState: marketStatePDA,
        authority: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Create a new binary prediction market
   */
  async createMarket(params: CreateSimpleMarketParams): Promise<bigint> {
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    // Get current market counter to determine market ID
    // @ts-ignore - Account types will be available after IDL generation
    const marketState = await (this.program.account as any).marketState.fetch(marketStatePDA);
    const marketId = marketState.marketCounter;
    
    const [marketPDA] = await this.getMarketPDA(marketId);
    
    // @ts-ignore - Method types will be available after IDL generation
    const tx = await (this.program.methods as any)
      .createMarket(params.question, new BN(params.resolutionTime))
      .accounts({
        marketAccount: marketPDA,
        marketState: marketStatePDA,
        creator: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return BigInt(marketId.toString());
  }

  /**
   * Take a position on a market (YES or NO)
   */
  async takePosition(marketId: bigint, isYes: boolean, amount: bigint): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [positionPDA] = await this.getPositionPDA(marketId, this.provider.wallet.publicKey);
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    // @ts-ignore - Method types will be available after IDL generation
    const tx = await (this.program.methods as any)
      .takePosition(new BN(marketId.toString()), isYes)
      .accounts({
        marketAccount: marketPDA,
        position: positionPDA,
        marketState: marketStatePDA,
        bettor: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Resolve market using oracle answer
   */
  async resolveMarket(marketId: bigint, oracleAnswerPDA: PublicKey): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    // @ts-ignore - Method types will be available after IDL generation
    const tx = await (this.program.methods as any)
      .resolveMarket(new BN(marketId.toString()))
      .accounts({
        marketAccount: marketPDA,
        marketState: marketStatePDA,
        oracleAnswer: oracleAnswerPDA,
      })
      .rpc();

    return tx;
  }

  /**
   * Claim winnings from a resolved market
   */
  async claimWinnings(marketId: bigint): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [positionPDA] = await this.getPositionPDA(marketId, this.provider.wallet.publicKey);
    
    // @ts-ignore - Method types will be available after IDL generation
    const tx = await (this.program.methods as any)
      .claimWinnings(new BN(marketId.toString()))
      .accounts({
        marketAccount: marketPDA,
        position: positionPDA,
        winner: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Get market details
   */
  async getMarket(marketId: bigint): Promise<SimpleMarket | null> {
    try {
      const [marketPDA] = await this.getMarketPDA(marketId);
      // @ts-ignore - Account types will be available after IDL generation
      const market = await (this.program.account as any).marketAccount.fetch(marketPDA);
      
      return {
        marketId: BigInt(market.marketId.toString()),
        question: market.question,
        resolutionTime: market.resolutionTime.toNumber(),
        yesPool: BigInt(market.yesPool.toString()),
        noPool: BigInt(market.noPool.toString()),
        status: market.status as MarketStatus,
        outcome: market.outcome as Outcome,
        totalFees: BigInt(market.totalFees.toString()),
        createdAt: market.createdAt.toNumber(),
        creator: market.creator,
      };
    } catch (error) {
      return null;
    }
  }

  /**
   * Get user position
   */
  async getPosition(marketId: bigint, user: PublicKey): Promise<SimplePosition | null> {
    try {
      const [positionPDA] = await this.getPositionPDA(marketId, user);
      // @ts-ignore - Account types will be available after IDL generation
      const position = await (this.program.account as any).position.fetch(positionPDA);
      
      return {
        yesAmount: BigInt(position.yesAmount.toString()),
        noAmount: BigInt(position.noAmount.toString()),
        claimed: position.claimed,
      };
    } catch (error) {
      return null;
    }
  }

  /**
   * Calculate potential winnings for a user
   */
  async calculateWinnings(marketId: bigint, user: PublicKey): Promise<bigint> {
    const market = await this.getMarket(marketId);
    const position = await this.getPosition(marketId, user);
    
    if (!market || !position || market.status !== MarketStatus.Resolved || position.claimed) {
      return 0n;
    }

    const totalPool = market.yesPool + market.noPool;
    if (totalPool === 0n) return 0n;

    if (market.outcome === Outcome.Yes && position.yesAmount > 0n) {
      if (market.yesPool === 0n) return 0n;
      return (position.yesAmount * totalPool) / market.yesPool;
    } else if (market.outcome === Outcome.No && position.noAmount > 0n) {
      if (market.noPool === 0n) return 0n;
      return (position.noAmount * totalPool) / market.noPool;
    }

    return 0n;
  }

  /**
   * Get market PDA (public key) for a given market ID
   * Useful for conditional markets that reference parent markets
   */
  async getMarketPublicKey(marketId: bigint): Promise<PublicKey> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    return marketPDA;
  }
}

