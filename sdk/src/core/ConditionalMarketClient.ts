import {
  Connection,
  PublicKey,
  SystemProgram,
} from '@solana/web3.js';
import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
import {
  ConditionalMarket,
  ConditionalPosition,
  CreateConditionalMarketParams,
  ConditionalMarketStatus,
} from '../types';

const CONDITIONAL_MARKET_PROGRAM_ID = new PublicKey('condMktM3mP9vK8JqF2nH5xY7wD4bC6eA8g');
const MARKET_STATE_SEED = 'market_state';
const MARKET_SEED = 'market';
const POSITION_SEED = 'position';

type ConditionalMarketProgram = any;

export class ConditionalMarketClient {
  private connection: Connection;
  private program: Program<ConditionalMarketProgram>;
  private provider: AnchorProvider;
  public readonly programId: PublicKey;

  constructor(config: { programId?: PublicKey; rpcUrl: string; network: string }, wallet: Wallet) {
    this.programId = config.programId || CONDITIONAL_MARKET_PROGRAM_ID;
    
    this.connection = new Connection(config.rpcUrl, 'confirmed');
    this.provider = new AnchorProvider(
      this.connection,
      wallet,
      { commitment: 'confirmed' }
    );
    
    // Note: IDL will be generated by Anchor build
    this.program = new Program(
      {} as any,
      this.programId,
      this.provider
    );
  }

  private async getMarketStatePDA(): Promise<[PublicKey, number]> {
    return PublicKey.findProgramAddress(
      [Buffer.from(MARKET_STATE_SEED)],
      this.programId
    );
  }

  private async getMarketPDA(marketId: bigint): Promise<[PublicKey, number]> {
    const marketIdBuffer = Buffer.allocUnsafe(8);
    marketIdBuffer.writeBigUInt64LE(marketId, 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(MARKET_SEED), marketIdBuffer],
      this.programId
    );
  }

  private async getPositionPDA(marketId: bigint, user: PublicKey): Promise<[PublicKey, number]> {
    const marketIdBuffer = Buffer.allocUnsafe(8);
    marketIdBuffer.writeBigUInt64LE(marketId, 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(POSITION_SEED), marketIdBuffer, user.toBuffer()],
      this.programId
    );
  }

  /**
   * Initialize the conditional market program
   */
  async initialize(oracleProgram: PublicKey, feePercentage: number = 200): Promise<string> {
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    const tx = await this.program.methods
      .initialize(oracleProgram, feePercentage)
      .accounts({
        marketState: marketStatePDA,
        authority: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Create a new conditional prediction market
   */
  async createMarket(params: CreateConditionalMarketParams): Promise<bigint> {
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    // Get current market counter to determine market ID
    const marketState = await this.program.account.marketState.fetch(marketStatePDA);
    const marketId = marketState.marketCounter;
    
    const [marketPDA] = await this.getMarketPDA(marketId);
    
    const tx = await this.program.methods
      .createMarket(
        params.question,
        params.parentMarket,
        params.requiredParentOutcome
      )
      .accounts({
        marketAccount: marketPDA,
        marketState: marketStatePDA,
        creator: this.provider.wallet.publicKey,
        parentMarket: params.parentMarket,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return BigInt(marketId.toString());
  }

  /**
   * Take a position on a conditional market (YES or NO)
   */
  async takePosition(marketId: bigint, isYes: boolean, amount: bigint): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [positionPDA] = await this.getPositionPDA(marketId, this.provider.wallet.publicKey);
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    const market = await this.getMarket(marketId);
    if (!market) {
      throw new Error('Market not found');
    }
    
    const tx = await this.program.methods
      .takePosition(new BN(marketId.toString()), isYes)
      .accounts({
        marketAccount: marketPDA,
        position: positionPDA,
        marketState: marketStatePDA,
        bettor: this.provider.wallet.publicKey,
        parentMarket: market.parentMarket,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Check if parent market condition is met
   */
  async checkParentMarket(marketId: bigint): Promise<boolean> {
    const market = await this.getMarket(marketId);
    if (!market) return false;
    
    // This would typically call a program method to check parent market
    // For now, we check the market status
    return market.status === ConditionalMarketStatus.Active || 
           market.status === ConditionalMarketStatus.Resolved;
  }

  /**
   * Resolve conditional market using oracle answer
   */
  async resolveMarket(marketId: bigint, oracleAnswerPDA: PublicKey): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    const market = await this.getMarket(marketId);
    if (!market) {
      throw new Error('Market not found');
    }
    
    const tx = await this.program.methods
      .resolveMarket(new BN(marketId.toString()))
      .accounts({
        marketAccount: marketPDA,
        marketState: marketStatePDA,
        oracleAnswer: oracleAnswerPDA,
        parentMarket: market.parentMarket,
      })
      .rpc();

    return tx;
  }

  /**
   * Claim winnings from a resolved market
   */
  async claimWinnings(marketId: bigint): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [positionPDA] = await this.getPositionPDA(marketId, this.provider.wallet.publicKey);
    
    const tx = await this.program.methods
      .claimWinnings(new BN(marketId.toString()))
      .accounts({
        marketAccount: marketPDA,
        position: positionPDA,
        winner: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Get refund if parent condition not met
   */
  async getRefund(marketId: bigint): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [positionPDA] = await this.getPositionPDA(marketId, this.provider.wallet.publicKey);
    
    const tx = await this.program.methods
      .getRefund(new BN(marketId.toString()))
      .accounts({
        marketAccount: marketPDA,
        position: positionPDA,
        bettor: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Get market details
   */
  async getMarket(marketId: bigint): Promise<ConditionalMarket | null> {
    try {
      const [marketPDA] = await this.getMarketPDA(marketId);
      const market = await this.program.account.marketAccount.fetch(marketPDA);
      
      return {
        marketId: BigInt(market.marketId.toString()),
        question: market.question,
        parentMarket: market.parentMarket,
        requiredParentOutcome: market.requiredParentOutcome,
        yesPool: BigInt(market.yesPool.toString()),
        noPool: BigInt(market.noPool.toString()),
        totalFees: BigInt(market.totalFees.toString()),
        createdAt: market.createdAt.toNumber(),
        resolvedAt: market.resolvedAt?.toNumber() || 0,
        status: market.status as ConditionalMarketStatus,
        finalOutcome: market.finalOutcome || false,
      };
    } catch (error) {
      return null;
    }
  }

  /**
   * Get user position
   */
  async getPosition(marketId: bigint, user: PublicKey): Promise<ConditionalPosition | null> {
    try {
      const [positionPDA] = await this.getPositionPDA(marketId, user);
      const position = await this.program.account.position.fetch(positionPDA);
      
      return {
        yesAmount: BigInt(position.yesAmount.toString()),
        noAmount: BigInt(position.noAmount.toString()),
        claimed: position.claimed,
      };
    } catch (error) {
      return null;
    }
  }

  /**
   * Calculate potential winnings for a user
   */
  async calculateWinnings(marketId: bigint, user: PublicKey): Promise<bigint> {
    const market = await this.getMarket(marketId);
    const position = await this.getPosition(marketId, user);
    
    if (!market || !position || 
        market.status !== ConditionalMarketStatus.Resolved || 
        position.claimed) {
      return 0n;
    }

    const totalPool = market.yesPool + market.noPool;
    if (totalPool === 0n) return 0n;

    if (market.finalOutcome && position.yesAmount > 0n) {
      if (market.yesPool === 0n) return 0n;
      return (position.yesAmount * totalPool) / market.yesPool;
    } else if (!market.finalOutcome && position.noAmount > 0n) {
      if (market.noPool === 0n) return 0n;
      return (position.noAmount * totalPool) / market.noPool;
    }

    return 0n;
  }
}

