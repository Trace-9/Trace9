import {
  Connection,
  PublicKey,
  Keypair,
  Transaction,
  SystemProgram,
} from '@solana/web3.js';
import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
import { Trace9Config } from '../types';
import * as anchor from '@coral-xyz/anchor';

// IDL types will be generated by Anchor build
type PaymentFacilitator = any;

export interface PaymentFacilitatorConfig {
  programId: PublicKey;
  rpcUrl: string;
  network: 'mainnet-beta' | 'devnet' | 'testnet';
}

export interface SettlePaymentParams {
  amount: bigint; // SOL in lamports
  recipient: PublicKey;
  paymentId: Uint8Array; // 32-byte payment ID for replay prevention
}

export interface BatchSettlePaymentParams {
  amounts: bigint[];
  recipients: PublicKey[];
  paymentIds: Uint8Array[];
}

export class PaymentFacilitatorClient {
  private connection: Connection;
  private program: Program<PaymentFacilitator>;
  private provider: AnchorProvider;
  private config: PaymentFacilitatorConfig;
  public readonly programId: PublicKey;

  constructor(config: PaymentFacilitatorConfig, wallet: Wallet) {
    this.config = config;
    this.programId = config.programId;
    
    this.connection = new Connection(config.rpcUrl, 'confirmed');
    this.provider = new AnchorProvider(
      this.connection,
      wallet,
      { commitment: 'confirmed' }
    );
    
    // Note: IDL will be generated by Anchor build
    this.program = new Program(
      {} as any, // IDL will be loaded after anchor build
      config.programId,
      this.provider
    );
  }

  /**
   * Get the payment facilitator PDA
   */
  private async getFacilitatorPDA(): Promise<[PublicKey, number]> {
    return PublicKey.findProgramAddress(
      [Buffer.from('payment_facilitator')],
      this.programId
    );
  }

  /**
   * Initialize the payment facilitator
   */
  async initialize(platformFeeBps: number): Promise<string> {
    const [facilitatorPDA] = await this.getFacilitatorPDA();
    
    const tx = await this.program.methods
      .initialize(platformFeeBps)
      .accounts({
        facilitator: facilitatorPDA,
        authority: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Settle a single payment
   */
  async settlePayment(params: SettlePaymentParams): Promise<string> {
    const [facilitatorPDA] = await this.getFacilitatorPDA();
    
    // Convert payment ID to [u8; 32]
    const paymentIdSlice = params.paymentId.slice(0, 32);
    if (paymentIdSlice.length !== 32) {
      throw new Error('Payment ID must be 32 bytes');
    }
    const paymentIdArray = Array.from(paymentIdSlice) as unknown as [number; 32];
    
    const tx = await this.program.methods
      .settlePayment(new BN(params.amount.toString()), paymentIdArray)
      .accounts({
        facilitator: facilitatorPDA,
        payer: this.provider.wallet.publicKey,
        recipient: params.recipient,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Batch settle multiple payments
   */
  async batchSettlePayments(params: BatchSettlePaymentParams): Promise<string> {
    const [facilitatorPDA] = await this.getFacilitatorPDA();
    
    if (params.amounts.length != params.recipients.length || 
        params.amounts.length != params.paymentIds.length) {
      throw new Error('Invalid batch parameters: lengths must match');
    }
    
    const amounts = params.amounts.map(a => new BN(a.toString()));
    const paymentIdArrays = params.paymentIds.map(id => {
      const arr = Array.from(id.slice(0, 32));
      if (arr.length !== 32) {
        throw new Error('Payment ID must be 32 bytes');
      }
      return arr as unknown as [number; 32  ];
    });
    
    const tx = await this.program.methods
      .batchSettlePayments(amounts, params.recipients, paymentIdArrays)
      .accounts({
        facilitator: facilitatorPDA,
        payer: this.provider.wallet.publicKey,
        recipients: params.recipients,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Withdraw accumulated fees (authority only)
   */
  async withdrawFees(): Promise<string> {
    const [facilitatorPDA] = await this.getFacilitatorPDA();

    const tx = await this.program.methods
      .withdrawFees()
      .accounts({
        facilitator: facilitatorPDA,
        authority: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Update platform fee (authority only)
   */
  async updatePlatformFee(newFeeBps: number): Promise<string> {
    const [facilitatorPDA] = await this.getFacilitatorPDA();

    const tx = await this.program.methods
      .updatePlatformFee(newFeeBps)
      .accounts({
        facilitator: facilitatorPDA,
        authority: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Get facilitator state
   */
  async getFacilitatorState(): Promise<{
    authority: PublicKey;
    platformFeeBps: number;
    accumulatedFees: bigint;
  }> {
    const [facilitatorPDA] = await this.getFacilitatorPDA();
    
    try {
      const state = await this.program.account.paymentFacilitator.fetch(facilitatorPDA);
      return {
        authority: state.authority,
        platformFeeBps: state.platformFeeBps,
        accumulatedFees: state.accumulatedFees.toBigInt(),
      };
    } catch (error) {
      throw new Error(`Failed to fetch facilitator state: ${error}`);
    }
  }

  /**
   * Check if payment ID has been used
   */
  async isPaymentUsed(paymentId: Uint8Array): Promise<boolean> {
    const state = await this.getFacilitatorState();
    // Note: In production, you'd need to check the used_payments array
    // This is a simplified version
    return false;
  }
}


