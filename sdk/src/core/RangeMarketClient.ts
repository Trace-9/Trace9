import {
  Connection,
  PublicKey,
  SystemProgram,
} from '@solana/web3.js';
import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
import {
  RangeMarket,
  RangePosition,
  CreateRangeMarketParams,
} from '../types';

const RANGE_MARKET_PROGRAM_ID = new PublicKey('rangeMktM3mP9vK8JqF2nH5xY7wD4bC6eA8g');
const MARKET_STATE_SEED = 'market_state';
const MARKET_SEED = 'market';
const POSITION_SEED = 'position';

type RangeMarketProgram = any;

export class RangeMarketClient {
  private connection: Connection;
  private program: Program<RangeMarketProgram>;
  private provider: AnchorProvider;
  public readonly programId: PublicKey;

  constructor(config: { programId?: PublicKey; rpcUrl: string; network: string }, wallet: Wallet) {
    this.programId = config.programId || RANGE_MARKET_PROGRAM_ID;
    
    this.connection = new Connection(config.rpcUrl, 'confirmed');
    this.provider = new AnchorProvider(
      this.connection,
      wallet,
      { commitment: 'confirmed' }
    );
    
    // Note: IDL will be generated by Anchor build
    this.program = new Program(
      {} as any,
      this.programId,
      this.provider
    );
  }

  private async getMarketStatePDA(): Promise<[PublicKey, number]> {
    return PublicKey.findProgramAddress(
      [Buffer.from(MARKET_STATE_SEED)],
      this.programId
    );
  }

  private async getMarketPDA(marketId: bigint): Promise<[PublicKey, number]> {
    const marketIdBuffer = Buffer.allocUnsafe(8);
    marketIdBuffer.writeBigUInt64LE(marketId, 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(MARKET_SEED), marketIdBuffer],
      this.programId
    );
  }

  private async getPositionPDA(marketId: bigint, user: PublicKey): Promise<[PublicKey, number]> {
    const marketIdBuffer = Buffer.allocUnsafe(8);
    marketIdBuffer.writeBigUInt64LE(marketId, 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(POSITION_SEED), marketIdBuffer, user.toBuffer()],
      this.programId
    );
  }

  /**
   * Initialize the range market program
   */
  async initialize(oracleProgram: PublicKey, feePercentage: number = 200): Promise<string> {
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    const tx = await this.program.methods
      .initialize(oracleProgram, feePercentage)
      .accounts({
        marketState: marketStatePDA,
        authority: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Create a new range prediction market
   */
  async createMarket(params: CreateRangeMarketParams): Promise<bigint> {
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    // Get current market counter to determine market ID
    const marketState = await this.program.account.marketState.fetch(marketStatePDA);
    const marketId = marketState.marketCounter;
    
    const [marketPDA] = await this.getMarketPDA(marketId);
    
    const tx = await this.program.methods
      .createMarket(
        params.question,
        new BN(params.lowerBound.toString()),
        new BN(params.upperBound.toString()),
        new BN(params.deadline)
      )
      .accounts({
        marketAccount: marketPDA,
        marketState: marketStatePDA,
        creator: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return BigInt(marketId.toString());
  }

  /**
   * Take a position on a market (IN-RANGE or OUT-RANGE)
   */
  async takePosition(marketId: bigint, inRange: boolean, amount: bigint): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [positionPDA] = await this.getPositionPDA(marketId, this.provider.wallet.publicKey);
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    const tx = await this.program.methods
      .takePosition(new BN(marketId.toString()), inRange)
      .accounts({
        marketAccount: marketPDA,
        position: positionPDA,
        marketState: marketStatePDA,
        bettor: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Resolve market using oracle numeric answer
   */
  async resolveMarket(marketId: bigint, oracleAnswerPDA: PublicKey): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    const tx = await this.program.methods
      .resolveMarket(new BN(marketId.toString()))
      .accounts({
        marketAccount: marketPDA,
        marketState: marketStatePDA,
        oracleAnswer: oracleAnswerPDA,
      })
      .rpc();

    return tx;
  }

  /**
   * Claim winnings from a resolved market
   */
  async claimWinnings(marketId: bigint): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [positionPDA] = await this.getPositionPDA(marketId, this.provider.wallet.publicKey);
    
    const tx = await this.program.methods
      .claimWinnings(new BN(marketId.toString()))
      .accounts({
        marketAccount: marketPDA,
        position: positionPDA,
        winner: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Get market details
   */
  async getMarket(marketId: bigint): Promise<RangeMarket | null> {
    try {
      const [marketPDA] = await this.getMarketPDA(marketId);
      const market = await this.program.account.marketAccount.fetch(marketPDA);
      
      return {
        marketId: BigInt(market.marketId.toString()),
        question: market.question,
        lowerBound: BigInt(market.lowerBound.toString()),
        upperBound: BigInt(market.upperBound.toString()),
        inRangePool: BigInt(market.inRangePool.toString()),
        outRangePool: BigInt(market.outRangePool.toString()),
        totalFees: BigInt(market.totalFees.toString()),
        createdAt: market.createdAt.toNumber(),
        deadline: market.deadline.toNumber(),
        resolvedAt: market.resolvedAt?.toNumber() || 0,
        resolved: market.resolved || false,
        inRange: market.inRange || false,
      };
    } catch (error) {
      return null;
    }
  }

  /**
   * Get user position
   */
  async getPosition(marketId: bigint, user: PublicKey): Promise<RangePosition | null> {
    try {
      const [positionPDA] = await this.getPositionPDA(marketId, user);
      const position = await this.program.account.position.fetch(positionPDA);
      
      return {
        inRangeAmount: BigInt(position.inRangeAmount.toString()),
        outRangeAmount: BigInt(position.outRangeAmount.toString()),
        claimed: position.claimed,
      };
    } catch (error) {
      return null;
    }
  }

  /**
   * Calculate potential winnings for a user
   */
  async calculateWinnings(marketId: bigint, user: PublicKey): Promise<bigint> {
    const market = await this.getMarket(marketId);
    const position = await this.getPosition(marketId, user);
    
    if (!market || !position || !market.resolved || position.claimed) {
      return 0n;
    }

    const totalPool = market.inRangePool + market.outRangePool;
    if (totalPool === 0n) return 0n;

    if (market.inRange && position.inRangeAmount > 0n) {
      if (market.inRangePool === 0n) return 0n;
      return (position.inRangeAmount * totalPool) / market.inRangePool;
    } else if (!market.inRange && position.outRangeAmount > 0n) {
      if (market.outRangePool === 0n) return 0n;
      return (position.outRangeAmount * totalPool) / market.outRangePool;
    }

    return 0n;
  }
}

