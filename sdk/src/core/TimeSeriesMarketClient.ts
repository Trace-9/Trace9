import {
  Connection,
  PublicKey,
  SystemProgram,
} from '@solana/web3.js';
import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
import {
  TimeSeriesMarket,
  TimeSeriesPosition,
  CreateTimeSeriesMarketParams,
  TimePeriod,
} from '../types';

const TIME_SERIES_MARKET_PROGRAM_ID = new PublicKey('timeSerM3mP9vK8JqF2nH5xY7wD4bC6eA8g');
const MARKET_STATE_SEED = 'market_state';
const MARKET_SEED = 'market';
const POSITION_SEED = 'position';

type TimeSeriesMarketProgram = any;

export class TimeSeriesMarketClient {
  private connection: Connection;
  private program: Program<TimeSeriesMarketProgram>;
  private provider: AnchorProvider;
  public readonly programId: PublicKey;

  constructor(config: { programId?: PublicKey; rpcUrl: string; network: string }, wallet: Wallet) {
    this.programId = config.programId || TIME_SERIES_MARKET_PROGRAM_ID;
    
    this.connection = new Connection(config.rpcUrl, 'confirmed');
    this.provider = new AnchorProvider(
      this.connection,
      wallet,
      { commitment: 'confirmed' }
    );
    
    // Note: IDL will be generated by Anchor build
    this.program = new Program(
      {} as any,
      this.programId,
      this.provider
    );
  }

  private async getMarketStatePDA(): Promise<[PublicKey, number]> {
    return PublicKey.findProgramAddress(
      [Buffer.from(MARKET_STATE_SEED)],
      this.programId
    );
  }

  private async getMarketPDA(marketId: bigint): Promise<[PublicKey, number]> {
    const marketIdBuffer = Buffer.allocUnsafe(8);
    marketIdBuffer.writeBigUInt64LE(marketId, 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(MARKET_SEED), marketIdBuffer],
      this.programId
    );
  }

  private async getPositionPDA(marketId: bigint, user: PublicKey): Promise<[PublicKey, number]> {
    const marketIdBuffer = Buffer.allocUnsafe(8);
    marketIdBuffer.writeBigUInt64LE(marketId, 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(POSITION_SEED), marketIdBuffer, user.toBuffer()],
      this.programId
    );
  }

  /**
   * Initialize the time-series market program
   */
  async initialize(oracleProgram: PublicKey, feePercentage: number = 200): Promise<string> {
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    const tx = await this.program.methods
      .initialize(oracleProgram, feePercentage)
      .accounts({
        marketState: marketStatePDA,
        authority: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Create a new time-series prediction market
   */
  async createMarket(params: CreateTimeSeriesMarketParams): Promise<bigint> {
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    // Get current market counter to determine market ID
    const marketState = await this.program.account.marketState.fetch(marketStatePDA);
    const marketId = marketState.marketCounter;
    
    const [marketPDA] = await this.getMarketPDA(marketId);
    
    const tx = await this.program.methods
      .createMarket(
        params.question,
        params.deadlines.map(d => new BN(d))
      )
      .accounts({
        marketAccount: marketPDA,
        marketState: marketStatePDA,
        creator: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return BigInt(marketId.toString());
  }

  /**
   * Take a position on a market (ALL-SUCCEED or ANY-FAIL)
   */
  async takePosition(marketId: bigint, allSucceed: boolean, amount: bigint): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [positionPDA] = await this.getPositionPDA(marketId, this.provider.wallet.publicKey);
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    const tx = await this.program.methods
      .takePosition(new BN(marketId.toString()), allSucceed)
      .accounts({
        marketAccount: marketPDA,
        position: positionPDA,
        marketState: marketStatePDA,
        bettor: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Resolve a specific period using oracle answer
   */
  async resolvePeriod(marketId: bigint, periodIndex: number, oracleAnswerPDA: PublicKey): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    const tx = await this.program.methods
      .resolvePeriod(new BN(marketId.toString()), periodIndex)
      .accounts({
        marketAccount: marketPDA,
        marketState: marketStatePDA,
        oracleAnswer: oracleAnswerPDA,
      })
      .rpc();

    return tx;
  }

  /**
   * Claim winnings from a resolved market
   */
  async claimWinnings(marketId: bigint): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [positionPDA] = await this.getPositionPDA(marketId, this.provider.wallet.publicKey);
    
    const tx = await this.program.methods
      .claimWinnings(new BN(marketId.toString()))
      .accounts({
        marketAccount: marketPDA,
        position: positionPDA,
        winner: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Get market details
   */
  async getMarket(marketId: bigint): Promise<TimeSeriesMarket | null> {
    try {
      const [marketPDA] = await this.getMarketPDA(marketId);
      const market = await this.program.account.marketAccount.fetch(marketPDA);
      
      return {
        marketId: BigInt(market.marketId.toString()),
        question: market.question,
        periods: market.periods.map((p: any) => ({
          deadline: p.deadline.toNumber(),
          questionId: BigInt(p.questionId.toString()),
          result: BigInt(p.result.toString()),
          resolved: p.resolved || false,
        })),
        successPool: BigInt(market.successPool.toString()),
        failurePool: BigInt(market.failurePool.toString()),
        totalFees: BigInt(market.totalFees.toString()),
        createdAt: market.createdAt.toNumber(),
        allResolved: market.allResolved || false,
        allSuccess: market.allSuccess || false,
      };
    } catch (error) {
      return null;
    }
  }

  /**
   * Get user position
   */
  async getPosition(marketId: bigint, user: PublicKey): Promise<TimeSeriesPosition | null> {
    try {
      const [positionPDA] = await this.getPositionPDA(marketId, user);
      const position = await this.program.account.position.fetch(positionPDA);
      
      return {
        successAmount: BigInt(position.successAmount.toString()),
        failureAmount: BigInt(position.failureAmount.toString()),
        claimed: position.claimed,
      };
    } catch (error) {
      return null;
    }
  }

  /**
   * Calculate potential winnings for a user
   */
  async calculateWinnings(marketId: bigint, user: PublicKey): Promise<bigint> {
    const market = await this.getMarket(marketId);
    const position = await this.getPosition(marketId, user);
    
    if (!market || !position || !market.allResolved || position.claimed) {
      return 0n;
    }

    const totalPool = market.successPool + market.failurePool;
    if (totalPool === 0n) return 0n;

    // User wins if they bet on the correct outcome
    if (market.allSuccess && position.successAmount > 0n) {
      if (market.successPool === 0n) return 0n;
      return (position.successAmount * totalPool) / market.successPool;
    } else if (!market.allSuccess && position.failureAmount > 0n) {
      if (market.failurePool === 0n) return 0n;
      return (position.failureAmount * totalPool) / market.failurePool;
    }

    return 0n;
  }
}

