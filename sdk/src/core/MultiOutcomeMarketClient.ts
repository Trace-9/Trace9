import {
  Connection,
  PublicKey,
  SystemProgram,
} from '@solana/web3.js';
import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
import {
  MultiOutcomeMarket,
  MultiOutcomePosition,
  CreateMultiOutcomeMarketParams,
  MarketStatus,
} from '../types';

const MULTI_OUTCOME_MARKET_PROGRAM_ID = new PublicKey('multiOutM3mP9vK8JqF2nH5xY7wD4bC6eA8g');
const MARKET_STATE_SEED = 'market_state';
const MARKET_SEED = 'market';
const POSITION_SEED = 'position';

type MultiOutcomeMarketProgram = any;

export class MultiOutcomeMarketClient {
  private connection: Connection;
  private program: Program<MultiOutcomeMarketProgram>;
  private provider: AnchorProvider;
  public readonly programId: PublicKey;

  constructor(config: { programId?: PublicKey; rpcUrl: string; network: string }, wallet: Wallet) {
    this.programId = config.programId || MULTI_OUTCOME_MARKET_PROGRAM_ID;
    
    this.connection = new Connection(config.rpcUrl, 'confirmed');
    this.provider = new AnchorProvider(
      this.connection,
      wallet,
      { commitment: 'confirmed' }
    );
    
    // Note: IDL will be generated by Anchor build
    this.program = new Program(
      {} as any,
      this.programId,
      this.provider
    );
  }

  private async getMarketStatePDA(): Promise<[PublicKey, number]> {
    return PublicKey.findProgramAddress(
      [Buffer.from(MARKET_STATE_SEED)],
      this.programId
    );
  }

  private async getMarketPDA(marketId: bigint): Promise<[PublicKey, number]> {
    const marketIdBuffer = Buffer.allocUnsafe(8);
    marketIdBuffer.writeBigUInt64LE(marketId, 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(MARKET_SEED), marketIdBuffer],
      this.programId
    );
  }

  private async getPositionPDA(marketId: bigint, user: PublicKey): Promise<[PublicKey, number]> {
    const marketIdBuffer = Buffer.allocUnsafe(8);
    marketIdBuffer.writeBigUInt64LE(marketId, 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(POSITION_SEED), marketIdBuffer, user.toBuffer()],
      this.programId
    );
  }

  /**
   * Initialize the multi-outcome market program
   */
  async initialize(oracleProgram: PublicKey, feePercentage: number = 200): Promise<string> {
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    const tx = await this.program.methods
      .initialize(oracleProgram, feePercentage)
      .accounts({
        marketState: marketStatePDA,
        authority: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Create a new multi-outcome prediction market
   */
  async createMarket(params: CreateMultiOutcomeMarketParams): Promise<bigint> {
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    // Get current market counter to determine market ID
    const marketState = await this.program.account.marketState.fetch(marketStatePDA);
    const marketId = marketState.marketCounter;
    
    const [marketPDA] = await this.getMarketPDA(marketId);
    
    const tx = await this.program.methods
      .createMarket(
        params.question,
        params.outcomeLabels,
        new BN(params.resolutionTime)
      )
      .accounts({
        marketAccount: marketPDA,
        marketState: marketStatePDA,
        creator: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return BigInt(marketId.toString());
  }

  /**
   * Take a position on a specific outcome
   */
  async takePosition(marketId: bigint, outcomeIndex: number, amount: bigint): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [positionPDA] = await this.getPositionPDA(marketId, this.provider.wallet.publicKey);
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    const tx = await this.program.methods
      .takePosition(new BN(marketId.toString()), outcomeIndex)
      .accounts({
        marketAccount: marketPDA,
        position: positionPDA,
        marketState: marketStatePDA,
        bettor: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Resolve market using oracle answer (numeric answer = outcome index)
   */
  async resolveMarket(marketId: bigint, oracleAnswerPDA: PublicKey): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [marketStatePDA] = await this.getMarketStatePDA();
    
    const tx = await this.program.methods
      .resolveMarket(new BN(marketId.toString()))
      .accounts({
        marketAccount: marketPDA,
        marketState: marketStatePDA,
        oracleAnswer: oracleAnswerPDA,
      })
      .rpc();

    return tx;
  }

  /**
   * Claim winnings from a resolved market
   */
  async claimWinnings(marketId: bigint): Promise<string> {
    const [marketPDA] = await this.getMarketPDA(marketId);
    const [positionPDA] = await this.getPositionPDA(marketId, this.provider.wallet.publicKey);
    
    const tx = await this.program.methods
      .claimWinnings(new BN(marketId.toString()))
      .accounts({
        marketAccount: marketPDA,
        position: positionPDA,
        winner: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Get market details
   */
  async getMarket(marketId: bigint): Promise<MultiOutcomeMarket | null> {
    try {
      const [marketPDA] = await this.getMarketPDA(marketId);
      const market = await this.program.account.marketAccount.fetch(marketPDA);
      
      return {
        marketId: BigInt(market.marketId.toString()),
        question: market.question,
        resolutionTime: market.resolutionTime.toNumber(),
        numOutcomes: market.numOutcomes,
        outcomeLabels: market.outcomeLabels,
        outcomePools: market.outcomePools.map((p: any) => BigInt(p.toString())),
        status: market.status as MarketStatus,
        winningOutcome: market.winningOutcome,
        totalPool: BigInt(market.totalPool.toString()),
        totalFees: BigInt(market.totalFees.toString()),
        createdAt: market.createdAt.toNumber(),
      };
    } catch (error) {
      return null;
    }
  }

  /**
   * Get user position
   */
  async getPosition(marketId: bigint, user: PublicKey): Promise<MultiOutcomePosition | null> {
    try {
      const [positionPDA] = await this.getPositionPDA(marketId, user);
      const position = await this.program.account.position.fetch(positionPDA);
      
      return {
        amounts: position.amounts.map((a: any) => BigInt(a.toString())),
        claimed: position.claimed,
      };
    } catch (error) {
      return null;
    }
  }

  /**
   * Calculate potential winnings for a user
   */
  async calculateWinnings(marketId: bigint, user: PublicKey): Promise<bigint> {
    const market = await this.getMarket(marketId);
    const position = await this.getPosition(marketId, user);
    
    if (!market || !position || market.status !== MarketStatus.Resolved || position.claimed) {
      return 0n;
    }

    const winningOutcome = market.winningOutcome;
    if (winningOutcome < 0 || winningOutcome >= position.amounts.length) {
      return 0n;
    }

    const userAmount = position.amounts[winningOutcome];
    if (userAmount === 0n) return 0n;

    const winningPool = market.outcomePools[winningOutcome];
    if (winningPool === 0n) return 0n;

    // Parimutuel calculation: (userAmount / winningPool) * totalPool
    return (userAmount * market.totalPool) / winningPool;
  }
}

