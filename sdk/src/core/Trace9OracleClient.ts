import {
  Connection,
  PublicKey,
  Keypair,
  Transaction,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
  sendAndConfirmTransaction,
  Commitment,
} from '@solana/web3.js';
import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
// IDL types will be generated by Anchor build
// For now, using any - will be properly typed after anchor build
type Trace9 = any;
import { Trace9Config, Question, Answer, QuestionWithAnswer, OracleState, AskQuestionParams, ProvideAnswerParams, QuestionType, AnswerStatus } from '../types';
import { TRACE9_PROGRAM_ID, ORACLE_STATE_SEED, QUESTION_SEED, ANSWER_SEED } from '../utils/constants';
import * as anchor from '@coral-xyz/anchor';

export class Trace9OracleClient {
  private connection: Connection;
  private program: Program<Trace9>;
  private provider: AnchorProvider;
  private config: Trace9Config;
  public readonly programId: PublicKey;

  constructor(config: Trace9Config, wallet: Wallet) {
    this.config = config;
    this.programId = config.programId;
    
    this.connection = new Connection(config.rpcUrl, 'confirmed');
    this.provider = new AnchorProvider(
      this.connection,
      wallet,
      { commitment: 'confirmed' }
    );
    
    // Note: IDL will be generated by Anchor build
    // After running `anchor build`, the IDL will be available at target/idl/trace9.json
    // For development, we use a placeholder - in production, load the IDL:
    // import idl from '../idl/trace9.json';
    // this.program = new Program(idl as any, config.programId, this.provider);
    // @ts-ignore - IDL will be loaded after anchor build, types will be correct then
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    this.program = new Program({} as any, config.programId, this.provider) as Program<any>;
  }

  /**
   * Get the oracle state PDA
   */
  private async getOracleStatePDA(): Promise<[PublicKey, number]> {
    return PublicKey.findProgramAddress(
      [Buffer.from(ORACLE_STATE_SEED)],
      this.programId
    );
  }

  /**
   * Get question account PDA
   */
  private async getQuestionPDA(questionId: number): Promise<[PublicKey, number]> {
    const questionIdBuffer = Buffer.allocUnsafe(8);
    questionIdBuffer.writeBigUInt64LE(BigInt(questionId), 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(QUESTION_SEED), questionIdBuffer],
      this.programId
    );
  }

  /**
   * Get answer account PDA
   */
  private async getAnswerPDA(questionId: number): Promise<[PublicKey, number]> {
    const questionIdBuffer = Buffer.allocUnsafe(8);
    questionIdBuffer.writeBigUInt64LE(BigInt(questionId), 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(ANSWER_SEED), questionIdBuffer],
      this.programId
    );
  }

  /**
   * Initialize the oracle program
   */
  async initialize(oracleProvider: PublicKey): Promise<string> {
    const [oracleStatePDA] = await this.getOracleStatePDA();
    
    // @ts-ignore - Method types will be available after IDL generation
    const tx = await (this.program.methods as any)
      .initialize(oracleProvider)
      .accounts({
        oracleState: oracleStatePDA,
        authority: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Ask a question to the oracle
   */
  async askQuestion(params: AskQuestionParams): Promise<string> {
    const [oracleStatePDA, oracleBump] = await this.getOracleStatePDA();
    
    // Fetch current question counter
    const oracleState = await this.getOracleState();
    const questionId = Number(oracleState.questionCounter);
    
    const [questionPDA, questionBump] = await this.getQuestionPDA(questionId);

    // @ts-ignore - Method types will be available after IDL generation
    const tx = await (this.program.methods as any)
      .askQuestion(
        { [QuestionType[params.questionType].toLowerCase()]: {} } as any,
        params.question,
        new BN(params.deadline)
      )
      .accounts({
        questionAccount: questionPDA,
        oracleState: oracleStatePDA,
        requester: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([])
      .rpc();

    return tx;
  }

  /**
   * Provide an answer to a question (oracle provider only)
   */
  async provideAnswer(params: ProvideAnswerParams): Promise<string> {
    const questionId = parseInt(params.questionId);
    const [questionPDA] = await this.getQuestionPDA(questionId);
    const [answerPDA] = await this.getAnswerPDA(questionId);
    const [oracleStatePDA] = await this.getOracleStatePDA();

    // @ts-ignore - Method types will be available after IDL generation
    const tx = await (this.program.methods as any)
      .provideAnswer(
        params.textAnswer,
        new BN(params.numericAnswer.toString()),
        params.boolAnswer,
        params.confidenceScore,
        params.dataSource
      )
      .accounts({
        questionAccount: questionPDA,
        answerAccount: answerPDA,
        oracleState: oracleStatePDA,
        oracleProvider: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Refund an unanswered question after refund period
   */
  async refundQuestion(questionId: string): Promise<string> {
    const qId = parseInt(questionId);
    const [questionPDA] = await this.getQuestionPDA(qId);

    // @ts-ignore - Method types will be available after IDL generation
    const tx = await (this.program.methods as any)
      .refundQuestion()
      .accounts({
        questionAccount: questionPDA,
        requester: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Withdraw provider earnings
   */
  async withdraw(): Promise<string> {
    const [oracleStatePDA] = await this.getOracleStatePDA();

    // @ts-ignore - Method types will be available after IDL generation
    const tx = await (this.program.methods as any)
      .withdraw()
      .accounts({
        oracleState: oracleStatePDA,
        oracleProvider: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Get oracle state
   */
  async getOracleState(): Promise<OracleState> {
    const [oracleStatePDA] = await this.getOracleStatePDA();
    
    try {
      // @ts-ignore - Account types will be available after IDL generation
      const state = await (this.program.account as any).oracleState.fetch(oracleStatePDA);
      return {
        authority: state.authority,
        oracleProvider: state.oracleProvider,
        questionCounter: state.questionCounter.toBigInt(),
        oracleFee: state.oracleFee.toBigInt(),
        providerBalance: state.providerBalance.toBigInt(),
      };
    } catch (error) {
      throw new Error(`Failed to fetch oracle state: ${error}`);
    }
  }

  /**
   * Get question with answer if available
   */
  async getQuestion(questionId: string): Promise<QuestionWithAnswer | null> {
    try {
      const qId = parseInt(questionId);
      const [questionPDA] = await this.getQuestionPDA(qId);
      
      // @ts-ignore - Account types will be available after IDL generation
      const questionAccount = await (this.program.account as any).questionAccount.fetch(questionPDA);
      
      const question: Question = {
        questionId: questionId,
        requester: questionAccount.requester,
        questionType: questionAccount.questionType as QuestionType,
        questionHash: questionAccount.questionHash,
        bounty: questionAccount.bounty.toBigInt(),
        timestamp: questionAccount.timestamp.toNumber(),
        deadline: questionAccount.deadline.toNumber(),
        status: questionAccount.status as AnswerStatus,
        refunded: questionAccount.refunded,
      };

      // Try to fetch answer if available
      let answer: Answer | undefined;
      try {
        const [answerPDA] = await this.getAnswerPDA(qId);
        // @ts-ignore - Account types will be available after IDL generation
        const answerAccount = await (this.program.account as any).answerAccount.fetch(answerPDA);
        
        answer = {
          questionId: questionId,
          provider: answerAccount.provider,
          confidenceScore: answerAccount.confidenceScore,
          boolAnswer: answerAccount.boolAnswer,
          numericAnswer: answerAccount.numericAnswer.toBigInt(),
          timestamp: answerAccount.timestamp.toNumber(),
        };
      } catch {
        // Answer doesn't exist yet
      }

      return {
        ...question,
        answer,
      };
    } catch (error) {
      console.error('Error fetching question:', error);
      return null;
    }
  }

  /**
   * Get question fee
   */
  async getQuestionFee(): Promise<bigint> {
    const state = await this.getOracleState();
    return state.oracleFee;
  }

  /**
   * Set oracle fee (authority only)
   */
  async setOracleFee(newFee: bigint): Promise<string> {
    const [oracleStatePDA] = await this.getOracleStatePDA();

    // @ts-ignore - Method types will be available after IDL generation
    const tx = await (this.program.methods as any)
      .setOracleFee(new BN(newFee.toString()))
      .accounts({
        oracleState: oracleStatePDA,
        authority: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Set oracle provider (authority only)
   */
  async setOracleProvider(newProvider: PublicKey): Promise<string> {
    const [oracleStatePDA] = await this.getOracleStatePDA();

    // @ts-ignore - Method types will be available after IDL generation
    const tx = await (this.program.methods as any)
      .setOracleProvider(newProvider)
      .accounts({
        oracleState: oracleStatePDA,
        authority: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Batch ask multiple questions
   */
  async batchAskQuestions(params: {
    questionTypes: QuestionType[];
    questions: string[];
    deadlines: number[];
  }): Promise<string[]> {
    if (params.questions.length !== params.deadlines.length || 
        params.questions.length !== params.questionTypes.length) {
      throw new Error('All arrays must have the same length');
    }

    const [oracleStatePDA] = await this.getOracleStatePDA();
    
    const questionTypes = params.questionTypes.map(qt => {
      switch (qt) {
        case QuestionType.General:
          return { general: {} };
        case QuestionType.Price:
          return { price: {} };
        case QuestionType.YesNo:
          return { yesNo: {} };
        case QuestionType.Numeric:
          return { numeric: {} };
        default:
          throw new Error(`Unknown question type: ${qt}`);
      }
    }) as any;

    const deadlines = params.deadlines.map(d => new BN(d));

    // @ts-ignore - Method types will be available after IDL generation
    const questionIds = await (this.program.methods as any)
      .batchAskQuestions(questionTypes, params.questions, deadlines)
      .accounts({
        oracleState: oracleStatePDA,
        requester: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    // Note: The program returns Vec<u64>, but we need to parse it from logs/events
    // For now, return empty array - in production, parse from transaction logs
    return [];
  }

  /**
   * Batch provide answers to multiple questions
   */
  async batchProvideAnswers(params: {
    questionIds: string[];
    textAnswers: string[];
    numericAnswers: bigint[];
    boolAnswers: boolean[];
    confidenceScores: number[];
    dataSources: string[];
  }): Promise<string> {
    if (params.questionIds.length !== params.textAnswers.length ||
        params.questionIds.length !== params.numericAnswers.length ||
        params.questionIds.length !== params.boolAnswers.length ||
        params.questionIds.length !== params.confidenceScores.length ||
        params.questionIds.length !== params.dataSources.length) {
      throw new Error('All arrays must have the same length');
    }

    const [oracleStatePDA] = await this.getOracleStatePDA();

    const questionIds = params.questionIds.map(id => new BN(id));
    const numericAnswers = params.numericAnswers.map(a => new BN(a.toString()));

    // @ts-ignore - Method types will be available after IDL generation
    const tx = await (this.program.methods as any)
      .batchProvideAnswers(
        questionIds,
        params.textAnswers,
        numericAnswers,
        params.boolAnswers,
        params.confidenceScores,
        params.dataSources
      )
      .accounts({
        oracleState: oracleStatePDA,
        oracleProvider: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }
}

