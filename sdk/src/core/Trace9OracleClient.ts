import {
  Connection,
  PublicKey,
  Keypair,
  Transaction,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
  sendAndConfirmTransaction,
  Commitment,
} from '@solana/web3.js';
import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
// IDL types will be generated by Anchor build
// For now, using any - will be properly typed after anchor build
type Trace9 = any;
import { Trace9Config, Question, Answer, QuestionWithAnswer, OracleState, AskQuestionParams, ProvideAnswerParams, QuestionType, AnswerStatus } from '../types';
import { TRACE9_PROGRAM_ID, ORACLE_STATE_SEED, QUESTION_SEED, ANSWER_SEED } from '../utils/constants';
import * as anchor from '@coral-xyz/anchor';

export class Trace9OracleClient {
  private connection: Connection;
  private program: Program<Trace9>;
  private provider: AnchorProvider;
  private config: Trace9Config;
  public readonly programId: PublicKey;

  constructor(config: Trace9Config, wallet: Wallet) {
    this.config = config;
    this.programId = config.programId;
    
    this.connection = new Connection(config.rpcUrl, 'confirmed');
    this.provider = new AnchorProvider(
      this.connection,
      wallet,
      { commitment: 'confirmed' }
    );
    
    // Note: IDL will be generated by Anchor build
    // After running `anchor build`, the IDL will be available at target/idl/trace9.json
    // For development, we use a placeholder - in production, load the IDL:
    // import idl from '../idl/trace9.json';
    // this.program = new Program(idl as any, config.programId, this.provider);
    this.program = new Program(
      {} as any, // IDL will be loaded after anchor build
      config.programId,
      this.provider
    );
  }

  /**
   * Get the oracle state PDA
   */
  private async getOracleStatePDA(): Promise<[PublicKey, number]> {
    return PublicKey.findProgramAddress(
      [Buffer.from(ORACLE_STATE_SEED)],
      this.programId
    );
  }

  /**
   * Get question account PDA
   */
  private async getQuestionPDA(questionId: number): Promise<[PublicKey, number]> {
    const questionIdBuffer = Buffer.allocUnsafe(8);
    questionIdBuffer.writeBigUInt64LE(BigInt(questionId), 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(QUESTION_SEED), questionIdBuffer],
      this.programId
    );
  }

  /**
   * Get answer account PDA
   */
  private async getAnswerPDA(questionId: number): Promise<[PublicKey, number]> {
    const questionIdBuffer = Buffer.allocUnsafe(8);
    questionIdBuffer.writeBigUInt64LE(BigInt(questionId), 0);
    
    return PublicKey.findProgramAddress(
      [Buffer.from(ANSWER_SEED), questionIdBuffer],
      this.programId
    );
  }

  /**
   * Initialize the oracle program
   */
  async initialize(oracleProvider: PublicKey): Promise<string> {
    const [oracleStatePDA] = await this.getOracleStatePDA();
    
    const tx = await this.program.methods
      .initialize(oracleProvider)
      .accounts({
        oracleState: oracleStatePDA,
        authority: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Ask a question to the oracle
   */
  async askQuestion(params: AskQuestionParams): Promise<string> {
    const [oracleStatePDA, oracleBump] = await this.getOracleStatePDA();
    
    // Fetch current question counter
    const oracleState = await this.getOracleState();
    const questionId = Number(oracleState.questionCounter);
    
    const [questionPDA, questionBump] = await this.getQuestionPDA(questionId);

    const tx = await this.program.methods
      .askQuestion(
        { [QuestionType[params.questionType].toLowerCase()]: {} } as any,
        params.question,
        new BN(params.deadline)
      )
      .accounts({
        questionAccount: questionPDA,
        oracleState: oracleStatePDA,
        requester: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([])
      .rpc();

    return tx;
  }

  /**
   * Provide an answer to a question (oracle provider only)
   */
  async provideAnswer(params: ProvideAnswerParams): Promise<string> {
    const questionId = parseInt(params.questionId);
    const [questionPDA] = await this.getQuestionPDA(questionId);
    const [answerPDA] = await this.getAnswerPDA(questionId);
    const [oracleStatePDA] = await this.getOracleStatePDA();

    const tx = await this.program.methods
      .provideAnswer(
        params.textAnswer,
        new BN(params.numericAnswer.toString()),
        params.boolAnswer,
        params.confidenceScore,
        params.dataSource
      )
      .accounts({
        questionAccount: questionPDA,
        answerAccount: answerPDA,
        oracleState: oracleStatePDA,
        oracleProvider: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Refund an unanswered question after refund period
   */
  async refundQuestion(questionId: string): Promise<string> {
    const qId = parseInt(questionId);
    const [questionPDA] = await this.getQuestionPDA(qId);

    const tx = await this.program.methods
      .refundQuestion()
      .accounts({
        questionAccount: questionPDA,
        requester: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Withdraw provider earnings
   */
  async withdraw(): Promise<string> {
    const [oracleStatePDA] = await this.getOracleStatePDA();

    const tx = await this.program.methods
      .withdraw()
      .accounts({
        oracleState: oracleStatePDA,
        oracleProvider: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Get oracle state
   */
  async getOracleState(): Promise<OracleState> {
    const [oracleStatePDA] = await this.getOracleStatePDA();
    
    try {
      const state = await this.program.account.oracleState.fetch(oracleStatePDA);
      return {
        authority: state.authority,
        oracleProvider: state.oracleProvider,
        questionCounter: state.questionCounter.toBigInt(),
        oracleFee: state.oracleFee.toBigInt(),
        providerBalance: state.providerBalance.toBigInt(),
      };
    } catch (error) {
      throw new Error(`Failed to fetch oracle state: ${error}`);
    }
  }

  /**
   * Get question with answer if available
   */
  async getQuestion(questionId: string): Promise<QuestionWithAnswer | null> {
    try {
      const qId = parseInt(questionId);
      const [questionPDA] = await this.getQuestionPDA(qId);
      
      const questionAccount = await this.program.account.questionAccount.fetch(questionPDA);
      
      const question: Question = {
        questionId: questionId,
        requester: questionAccount.requester,
        questionType: questionAccount.questionType as QuestionType,
        questionHash: questionAccount.questionHash,
        bounty: questionAccount.bounty.toBigInt(),
        timestamp: questionAccount.timestamp.toNumber(),
        deadline: questionAccount.deadline.toNumber(),
        status: questionAccount.status as AnswerStatus,
        refunded: questionAccount.refunded,
      };

      // Try to fetch answer if available
      let answer: Answer | undefined;
      try {
        const [answerPDA] = await this.getAnswerPDA(qId);
        const answerAccount = await this.program.account.answerAccount.fetch(answerPDA);
        
        answer = {
          questionId: questionId,
          provider: answerAccount.provider,
          confidenceScore: answerAccount.confidenceScore,
          boolAnswer: answerAccount.boolAnswer,
          numericAnswer: answerAccount.numericAnswer.toBigInt(),
          timestamp: answerAccount.timestamp.toNumber(),
        };
      } catch {
        // Answer doesn't exist yet
      }

      return {
        ...question,
        answer,
      };
    } catch (error) {
      console.error('Error fetching question:', error);
      return null;
    }
  }

  /**
   * Get question fee
   */
  async getQuestionFee(): Promise<bigint> {
    const state = await this.getOracleState();
    return state.oracleFee;
  }

  /**
   * Set oracle fee (authority only)
   */
  async setOracleFee(newFee: bigint): Promise<string> {
    const [oracleStatePDA] = await this.getOracleStatePDA();

    const tx = await this.program.methods
      .setOracleFee(new BN(newFee.toString()))
      .accounts({
        oracleState: oracleStatePDA,
        authority: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Set oracle provider (authority only)
   */
  async setOracleProvider(newProvider: PublicKey): Promise<string> {
    const [oracleStatePDA] = await this.getOracleStatePDA();

    const tx = await this.program.methods
      .setOracleProvider(newProvider)
      .accounts({
        oracleState: oracleStatePDA,
        authority: this.provider.wallet.publicKey,
      })
      .rpc();

    return tx;
  }
}

